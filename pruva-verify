#!/usr/bin/env bash
#
# pruva-verify - Verify a Pruva reproduction locally
#
# Usage:
#   pruva-verify REPRO-2026-00006
#   pruva-verify GHSA-655q-fx9r-782v
#   pruva-verify CVE-2025-1716
#
# Environment:
#   PRUVA_API_URL - API base URL (default: https://api.pruva.dev/v1)
#   PRUVA_KEEP_DIR - Set to 1 to keep the temp directory after verification
#
set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Config
API_URL="${PRUVA_API_URL:-https://api.pruva.dev/v1}"
KEEP_DIR="${PRUVA_KEEP_DIR:-1}"  # Keep results by default

# In Codespaces, use workspace dir so files are visible in VS Code explorer
if [[ -n "${PRUVA_RESULTS_DIR:-}" ]]; then
  RESULTS_DIR="$PRUVA_RESULTS_DIR"
elif [[ "${CODESPACES:-}" == "true" ]] && [[ -n "${GITHUB_REPOSITORY:-}" ]]; then
  # GITHUB_REPOSITORY is "owner/repo-name", extract repo name for /workspaces/<repo>
  REPO_NAME="${GITHUB_REPOSITORY##*/}"
  RESULTS_DIR="/workspaces/${REPO_NAME}/pruva-results"
else
  RESULTS_DIR="$HOME/pruva-results"
fi

log() { echo -e "${CYAN}[pruva]${NC} $*"; }
error() { echo -e "${RED}[pruva]${NC} $*" >&2; }
success() { echo -e "${GREEN}[pruva]${NC} $*"; }
warn() { echo -e "${YELLOW}[pruva]${NC} $*"; }

usage() {
  cat << EOF
${BOLD}pruva-verify${NC} - Verify a Pruva reproduction locally

${BOLD}USAGE:${NC}
    pruva-verify <REPRO_ID|GHSA_ID|CVE_ID>

${BOLD}EXAMPLES:${NC}
    pruva-verify REPRO-2026-00006
    pruva-verify GHSA-655q-fx9r-782v
    pruva-verify CVE-2025-1716

${BOLD}ENVIRONMENT:${NC}
    PRUVA_API_URL    API base URL (default: https://api.pruva.dev/v1)
    PRUVA_KEEP_DIR   Set to 1 to keep temp directory after verification

${BOLD}OPTIONS:${NC}
    -h, --help       Show this help message

${BOLD}WHAT IT DOES:${NC}
    1. Fetches reproduction metadata from Pruva API
    2. Downloads the reproduction script
    3. Runs it in an isolated temp directory
    4. Reports SUCCESS or FAILURE with details

${BOLD}WARNING:${NC}
    This runs code that exploits real vulnerabilities.
    Always run in a VM, container, or disposable environment.
EOF
}

# Parse arguments
if [[ $# -lt 1 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
  usage
  exit 0
fi

INPUT="$1"

# Determine the lookup endpoint based on input format
resolve_repro_id() {
  local input="$1"

  if [[ "$input" =~ ^REPRO-[0-9]{4}-[0-9]+$ ]]; then
    # Direct REPRO ID
    echo "$input"
  elif [[ "$input" =~ ^GHSA- ]]; then
    # GHSA lookup
    local response
    response=$(curl -sf "${API_URL}/reproductions/lookup/ghsa/${input}" 2>/dev/null) || {
      error "No reproduction found for ${input}"
      exit 1
    }
    echo "$response" | jq -r '.repro_id'
  elif [[ "$input" =~ ^CVE- ]]; then
    # CVE lookup
    local response
    response=$(curl -sf "${API_URL}/reproductions/lookup/cve/${input}" 2>/dev/null) || {
      error "No reproduction found for ${input}"
      exit 1
    }
    echo "$response" | jq -r '.repro_id'
  else
    error "Invalid ID format: ${input}"
    error "Expected: REPRO-YYYY-NNNNN, GHSA-xxxx-xxxx-xxxx, or CVE-YYYY-NNNNN"
    exit 1
  fi
}

# Check dependencies
check_deps() {
  local missing=()
  for cmd in curl jq; do
    if ! command -v "$cmd" &>/dev/null; then
      missing+=("$cmd")
    fi
  done
  if [[ ${#missing[@]} -gt 0 ]]; then
    error "Missing required dependencies: ${missing[*]}"
    exit 1
  fi
}

check_deps

# Load and display environment version
if [[ -f "/etc/pruva-sandbox-version" ]]; then
  source /etc/pruva-sandbox-version
  log "Environment: pruva-sandbox ${PRUVA_SANDBOX_VERSION:-unknown} (${PRUVA_SANDBOX_SHA:-unknown})"
fi

log "Resolving ${BOLD}${INPUT}${NC}..."
REPRO_ID=$(resolve_repro_id "$INPUT")
log "Found reproduction: ${BOLD}${REPRO_ID}${NC}"

# Fetch reproduction metadata
log "Fetching metadata..."
METADATA=$(curl -sf "${API_URL}/reproductions/${REPRO_ID}" 2>/dev/null) || {
  error "Failed to fetch reproduction metadata"
  exit 1
}

TITLE=$(echo "$METADATA" | jq -r '.title // "Unknown"')
SEVERITY=$(echo "$METADATA" | jq -r '.severity // "unknown"' | tr '[:lower:]' '[:upper:]')
GHSA_ID=$(echo "$METADATA" | jq -r '.ghsa_id // empty')
CVE_ID=$(echo "$METADATA" | jq -r '.cve_id // empty')

# Check for environment version mismatch
REQUIRED_ENV=$(echo "$METADATA" | jq -r '.environment.sandbox_version // empty')
if [[ -n "$REQUIRED_ENV" ]] && [[ -n "${PRUVA_SANDBOX_VERSION:-}" ]]; then
  if [[ "$PRUVA_SANDBOX_VERSION" != "$REQUIRED_ENV" ]]; then
    warn "Version mismatch: reproduction created with ${REQUIRED_ENV}, running in ${PRUVA_SANDBOX_VERSION}"
  fi
fi

echo ""
echo -e "${BOLD}========================================${NC}"
echo -e "${BOLD}${REPRO_ID}${NC}"
echo -e "${BOLD}========================================${NC}"
echo -e "${BOLD}Title:${NC}    ${TITLE}"
echo -e "${BOLD}Severity:${NC} ${SEVERITY}"
[[ -n "$GHSA_ID" ]] && echo -e "${BOLD}GHSA:${NC}     ${GHSA_ID}"
[[ -n "$CVE_ID" ]] && echo -e "${BOLD}CVE:${NC}      ${CVE_ID}"
echo -e "${BOLD}========================================${NC}"
echo ""

# Create work directory in home (persists for user inspection)
mkdir -p "$RESULTS_DIR"
WORK_DIR="${RESULTS_DIR}/${REPRO_ID}"

# Clean previous run if exists
if [[ -d "$WORK_DIR" ]]; then
  log "Removing previous run directory..."
  rm -rf "$WORK_DIR"
fi

mkdir -p "$WORK_DIR"
log "Working directory: ${WORK_DIR}"

cleanup() {
  if [[ "$KEEP_DIR" == "1" ]]; then
    warn "Keeping work directory: ${WORK_DIR}"
  else
    rm -rf "$WORK_DIR"
  fi
}
trap cleanup EXIT

# Find the reproduction script from metadata
# Use reproduction_script field if set, otherwise prefer repro/ path, then largest
SCRIPT_ARTIFACT=$(echo "$METADATA" | jq -r '
  if .reproduction_script then
    .reproduction_script
  else
    ([.artifacts[] | select(.category == "reproduction_script" and (.path | startswith("repro/")))] | first | .path) //
    ([.artifacts[] | select(.category == "reproduction_script")] | sort_by(.size) | last | .path)
  end // empty
')

if [[ -z "$SCRIPT_ARTIFACT" ]]; then
  error "No reproduction script found in metadata"
  exit 1
fi

log "Found script artifact: ${SCRIPT_ARTIFACT}"

# Download all repro/ artifacts (scripts may depend on companion files like mock servers)
REPRO_ARTIFACTS=$(echo "$METADATA" | jq -r '[.artifacts[] | select(.path | startswith("repro/"))] | .[].path')
ARTIFACT_COUNT=0

for artifact_path in $REPRO_ARTIFACTS; do
  artifact_dir=$(dirname "$artifact_path")
  mkdir -p "${WORK_DIR}/${artifact_dir}"
  artifact_url="${API_URL}/reproductions/${REPRO_ID}/artifacts/${artifact_path}"
  if curl -sf "$artifact_url" -o "${WORK_DIR}/${artifact_path}" 2>/dev/null; then
    ARTIFACT_COUNT=$((ARTIFACT_COUNT + 1))
    # Make scripts executable
    if [[ "$artifact_path" == *.sh ]] || [[ "$artifact_path" == *.py ]]; then
      chmod +x "${WORK_DIR}/${artifact_path}"
    fi
  fi
done

SCRIPT_PATH="${WORK_DIR}/${SCRIPT_ARTIFACT}"
if [[ ! -f "$SCRIPT_PATH" ]]; then
  error "Failed to download reproduction script"
  exit 1
fi

chmod +x "$SCRIPT_PATH"
log "Downloaded ${ARTIFACT_COUNT} repro artifact(s), script: $(wc -l < "$SCRIPT_PATH") lines"

# Make script portable by replacing hardcoded paths
# Scripts may have BASE_DIR="/root/.pruva/runs/.../bundle" or similar
# We need to rewrite these to use WORK_DIR instead
ORIGINAL_BASE=$(grep 'BASE_DIR=' "$SCRIPT_PATH" | head -1 | sed -n 's/.*BASE_DIR="\([^"]*\)".*/\1/p' || true)
if [[ -n "$ORIGINAL_BASE" ]]; then
  log "Rewriting paths: ${ORIGINAL_BASE} â†’ ${WORK_DIR}"
  # Use temp file for portability (macOS sed -i requires extension)
  sed "s|${ORIGINAL_BASE}|${WORK_DIR}|g" "$SCRIPT_PATH" > "${SCRIPT_PATH}.tmp"
  mv "${SCRIPT_PATH}.tmp" "$SCRIPT_PATH"
  chmod +x "$SCRIPT_PATH"
fi

# Warning
echo ""
warn "=========================================="
warn "  WARNING: This will execute code that"
warn "  exploits a real vulnerability."
warn "=========================================="
echo ""

# Ask for confirmation (skip in Codespaces or non-interactive)
if [[ "${CODESPACES:-}" == "true" ]] || [[ "${PRUVA_SANDBOX:-}" == "true" ]]; then
  log "Auto-confirming in sandbox environment..."
elif [[ -t 0 ]]; then
  read -p "Continue? [y/N] " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    log "Aborted."
    exit 0
  fi
fi

# Run the script
log "Running reproduction script..."
echo ""
echo -e "${BOLD}--- REPRODUCTION OUTPUT ---${NC}"
echo ""

cd "$WORK_DIR"
START_TIME=$(date +%s)

if "./${SCRIPT_ARTIFACT}"; then
  END_TIME=$(date +%s)
  DURATION=$((END_TIME - START_TIME))
  echo ""
  echo -e "${BOLD}--- END REPRODUCTION OUTPUT ---${NC}"
  echo ""
  success "=========================================="
  success "  VERIFICATION SUCCESSFUL"
  success "  Duration: ${DURATION}s"
  success "=========================================="
  echo ""

  # Show result.json if exists
  if [[ -f "${WORK_DIR}/logs/result.json" ]]; then
    log "Result:"
    cat "${WORK_DIR}/logs/result.json" | head -1
    echo ""
  fi

  # Show logs summary
  if [[ -d "${WORK_DIR}/logs" ]]; then
    log "Logs: ${WORK_DIR}/logs/"
    ls -1 "${WORK_DIR}/logs/" 2>/dev/null | while read -r f; do
      echo "    - $f"
    done
  fi

  echo ""
  log "Results saved to: ${BOLD}${WORK_DIR}${NC}"

  exit 0
else
  EXIT_CODE=$?
  END_TIME=$(date +%s)
  DURATION=$((END_TIME - START_TIME))
  echo ""
  echo -e "${BOLD}--- END REPRODUCTION OUTPUT ---${NC}"
  echo ""
  error "=========================================="
  error "  VERIFICATION FAILED (exit code: ${EXIT_CODE})"
  error "  Duration: ${DURATION}s"
  error "=========================================="
  echo ""

  # Show logs for debugging
  if [[ -d "${WORK_DIR}/logs" ]]; then
    error "Logs: ${WORK_DIR}/logs/"
    ls -1 "${WORK_DIR}/logs/" 2>/dev/null | while read -r f; do
      echo "    - $f"
    done
    echo ""
    if [[ -f "${WORK_DIR}/logs/repro.log" ]]; then
      error "Last 20 lines of repro.log:"
      tail -20 "${WORK_DIR}/logs/repro.log" | while read -r line; do
        echo "    $line"
      done
    fi
  fi

  echo ""
  log "Results saved to: ${BOLD}${WORK_DIR}${NC}"

  exit 1
fi
